import 'dart:typed_data';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import '../models/scanned_document.dart';

/// Service for generating PDF documents from scanned images
class PdfGenerator {
  /// Generate PDF from processed image data
  Future<Uint8List> generatePdf({
    required Uint8List imageData,
    required DocumentType documentType,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final pdf = pw.Document();
      
      // Create PDF page with the image
      final image = pw.MemoryImage(imageData);
      
      pdf.addPage(
        pw.Page(
          pageFormat: _getPageFormat(documentType),
          margin: const pw.EdgeInsets.all(20),
          build: (pw.Context context) {
            return pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                // Add header with document info
                _buildHeader(documentType, metadata),
                pw.SizedBox(height: 20),
                
                // Add the scanned image
                pw.Expanded(
                  child: pw.Center(
                    child: pw.Image(
                      image,
                      fit: pw.BoxFit.contain,
                    ),
                  ),
                ),
                
                // Add footer with scan info
                pw.SizedBox(height: 20),
                _buildFooter(metadata),
              ],
            );
          },
        ),
      );

      return await pdf.save();
    } catch (e) {
      throw Exception('Failed to generate PDF: $e');
    }
  }

  /// Generate multi-page PDF from multiple images
  Future<Uint8List> generateMultiPagePdf({
    required List<Uint8List> imageDataList,
    required DocumentType documentType,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final pdf = pw.Document();
      
      for (int i = 0; i < imageDataList.length; i++) {
        final imageData = imageDataList[i];
        final image = pw.MemoryImage(imageData);
        
        pdf.addPage(
          pw.Page(
            pageFormat: _getPageFormat(documentType),
            margin: const pw.EdgeInsets.all(20),
            build: (pw.Context context) {
              return pw.Column(
                crossAxisAlignment: pw.CrossAxisAlignment.start,
                children: [
                  // Add header with document info and page number
                  _buildHeader(documentType, metadata, pageNumber: i + 1, totalPages: imageDataList.length),
                  pw.SizedBox(height: 20),
                  
                  // Add the scanned image
                  pw.Expanded(
                    child: pw.Center(
                      child: pw.Image(
                        image,
                        fit: pw.BoxFit.contain,
                      ),
                    ),
                  ),
                  
                  // Add footer with scan info
                  pw.SizedBox(height: 20),
                  _buildFooter(metadata),
                ],
              );
            },
          ),
        );
      }

      return await pdf.save();
    } catch (e) {
      throw Exception('Failed to generate multi-page PDF: $e');
    }
  }

  /// Build PDF header with document information
  pw.Widget _buildHeader(
    DocumentType documentType,
    Map<String, dynamic>? metadata, {
    int? pageNumber,
    int? totalPages,
  }) {
    final title = _getDocumentTitle(documentType);
    final scanDate = metadata?['scanTime'] ?? DateTime.now().toIso8601String();
    
    return pw.Row(
      mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
      children: [
        pw.Column(
          crossAxisAlignment: pw.CrossAxisAlignment.start,
          children: [
            pw.Text(
              title,
              style: pw.TextStyle(
                fontSize: 16,
                fontWeight: pw.FontWeight.bold,
              ),
            ),
            pw.SizedBox(height: 4),
            pw.Text(
              'Scanned: ${_formatDate(scanDate)}',
              style: const pw.TextStyle(fontSize: 10),
            ),
          ],
        ),
        if (pageNumber != null && totalPages != null)
          pw.Text(
            'Page $pageNumber of $totalPages',
            style: const pw.TextStyle(fontSize: 10),
          ),
      ],
    );
  }

  /// Build PDF footer with metadata
  pw.Widget _buildFooter(Map<String, dynamic>? metadata) {
    final appName = metadata?['appName'] ?? 'Document Scanner';
    final version = metadata?['appVersion'] ?? '1.0.0';
    
    return pw.Row(
      mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
      children: [
        pw.Text(
          'Generated by $appName v$version',
          style: const pw.TextStyle(fontSize: 8),
        ),
        pw.Text(
          'Processed: ${_formatDate(DateTime.now().toIso8601String())}',
          style: const pw.TextStyle(fontSize: 8),
        ),
      ],
    );
  }

  /// Get appropriate page format for document type
  PdfPageFormat _getPageFormat(DocumentType documentType) {
    switch (documentType) {
      case DocumentType.receipt:
        // Use A4 portrait for receipts
        return PdfPageFormat.a4;
      case DocumentType.manual:
        // Use A4 portrait for manuals
        return PdfPageFormat.a4;
      case DocumentType.document:
        // Use A4 portrait for documents
        return PdfPageFormat.a4;
      case DocumentType.other:
        // Default to A4 portrait
        return PdfPageFormat.a4;
    }
  }

  /// Get document title based on type
  String _getDocumentTitle(DocumentType documentType) {
    switch (documentType) {
      case DocumentType.receipt:
        return 'Receipt';
      case DocumentType.manual:
        return 'Manual';
      case DocumentType.document:
        return 'Document';
      case DocumentType.other:
        return 'Scanned Document';
    }
  }

  /// Format date for display
  String _formatDate(String isoDate) {
    try {
      final date = DateTime.parse(isoDate);
      return '${date.day.toString().padLeft(2, '0')}/${date.month.toString().padLeft(2, '0')}/${date.year}';
    } catch (e) {
      return isoDate;
    }
  }

  /// Create PDF with custom layout for receipts
  Future<Uint8List> generateReceiptPdf({
    required Uint8List imageData,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final pdf = pw.Document();
      final image = pw.MemoryImage(imageData);
      
      pdf.addPage(
        pw.Page(
          pageFormat: PdfPageFormat.a4,
          margin: const pw.EdgeInsets.all(15),
          build: (pw.Context context) {
            return pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.stretch,
              children: [
                // Receipt header
                pw.Container(
                  padding: const pw.EdgeInsets.all(10),
                  decoration: pw.BoxDecoration(
                    border: pw.Border.all(color: PdfColors.black),
                  ),
                  child: pw.Column(
                    crossAxisAlignment: pw.CrossAxisAlignment.start,
                    children: [
                      pw.Text(
                        'RECEIPT',
                        style: pw.TextStyle(
                          fontSize: 18,
                          fontWeight: pw.FontWeight.bold,
                        ),
                      ),
                      pw.SizedBox(height: 5),
                      pw.Text(
                        'Scan Date: ${_formatDate(metadata?['scanTime'] ?? DateTime.now().toIso8601String())}',
                        style: const pw.TextStyle(fontSize: 12),
                      ),
                      if (metadata?['productBrand'] != null)
                        pw.Text(
                          'Product: ${metadata!['productBrand']} ${metadata['productModel'] ?? ''}',
                          style: const pw.TextStyle(fontSize: 12),
                        ),
                      if (metadata?['purchaseDate'] != null)
                        pw.Text(
                          'Purchase Date: ${_formatDate(metadata!['purchaseDate'])}',
                          style: const pw.TextStyle(fontSize: 12),
                        ),
                    ],
                  ),
                ),
                
                pw.SizedBox(height: 20),
                
                // Receipt image
                pw.Expanded(
                  child: pw.Container(
                    decoration: pw.BoxDecoration(
                      border: pw.Border.all(color: PdfColors.grey),
                    ),
                    child: pw.Padding(
                      padding: const pw.EdgeInsets.all(10),
                      child: pw.Image(
                        image,
                        fit: pw.BoxFit.contain,
                      ),
                    ),
                  ),
                ),
                
                pw.SizedBox(height: 10),
                
                // Footer
                pw.Container(
                  padding: const pw.EdgeInsets.all(5),
                  decoration: pw.BoxDecoration(
                    color: PdfColors.grey200,
                  ),
                  child: pw.Row(
                    mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                    children: [
                      pw.Text(
                        'Generated by RobaMia',
                        style: const pw.TextStyle(fontSize: 8),
                      ),
                      pw.Text(
                        'Document Scanner v1.0.0',
                        style: const pw.TextStyle(fontSize: 8),
                      ),
                    ],
                  ),
                ),
              ],
            );
          },
        ),
      );

      return await pdf.save();
    } catch (e) {
      throw Exception('Failed to generate receipt PDF: $e');
    }
  }

  /// Create PDF with custom layout for manuals
  Future<Uint8List> generateManualPdf({
    required Uint8List imageData,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final pdf = pw.Document();
      final image = pw.MemoryImage(imageData);
      
      pdf.addPage(
        pw.Page(
          pageFormat: PdfPageFormat.a4,
          margin: const pw.EdgeInsets.all(20),
          build: (pw.Context context) {
            return pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                // Manual header
                pw.Row(
                  mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                  children: [
                    pw.Column(
                      crossAxisAlignment: pw.CrossAxisAlignment.start,
                      children: [
                        pw.Text(
                          'INSTRUCTION MANUAL',
                          style: pw.TextStyle(
                            fontSize: 16,
                            fontWeight: pw.FontWeight.bold,
                          ),
                        ),
                        if (metadata?['productBrand'] != null)
                          pw.Text(
                            '${metadata!['productBrand']} ${metadata['productModel'] ?? ''}',
                            style: pw.TextStyle(
                              fontSize: 14,
                              fontWeight: pw.FontWeight.bold,
                            ),
                          ),
                      ],
                    ),
                    pw.Column(
                      crossAxisAlignment: pw.CrossAxisAlignment.end,
                      children: [
                        pw.Text(
                          'Downloaded: ${_formatDate(metadata?['downloadTime'] ?? DateTime.now().toIso8601String())}',
                          style: const pw.TextStyle(fontSize: 10),
                        ),
                        if (metadata?['sourceUrl'] != null)
                          pw.Text(
                            'Source: ${metadata!['sourceUrl']}',
                            style: const pw.TextStyle(fontSize: 8),
                          ),
                      ],
                    ),
                  ],
                ),
                
                pw.SizedBox(height: 20),
                
                // Manual content
                pw.Expanded(
                  child: pw.Center(
                    child: pw.Image(
                      image,
                      fit: pw.BoxFit.contain,
                    ),
                  ),
                ),
                
                pw.SizedBox(height: 20),
                
                // Footer
                _buildFooter(metadata),
              ],
            );
          },
        ),
      );

      return await pdf.save();
    } catch (e) {
      throw Exception('Failed to generate manual PDF: $e');
    }
  }
}

// AIDEV-NOTE: This PDF generator creates optimized PDFs for different document types
// with appropriate headers, footers, and metadata for easy organization